"""
File to generate the Pseudo-Cl power spectrum from a set of previously-generated ensemble of maps
"""
import numpy as np
import healpy as hp
import pymaster as nmt


# The map resolution that we're going to be processing
n_side = 256

# The number of maps in the ensemble
num_maps = 2_500

# The distribution from which the maps were generated from
distribution = 'Gaussian'
# distribution = 'LogNormal'

# The location of the maps
filepath = f"/cephfs/maraio/FlaskMaps/N1024_{distribution}_shift_0_01214_noise30/Maps_N{n_side}"

print(f'Computing the Pseudo-Cl values for {num_maps} maps at N={n_side} located at {filepath}')

# The mask that we want to apply to the maps
mask = hp.read_map(f'../../data/masks/SkyMask_N{n_side}_whstars.fits', dtype=float)

# Create a full-sky mask
mask_fullsky = np.ones_like(mask)

# Create the NaMaster field for our mask
field_mask_spin0 = nmt.NmtField(mask, None, spin=0, purify_e=False, purify_b=False, n_iter=3)
field_mask_spin2 = nmt.NmtField(mask, None, spin=2, purify_e=False, purify_b=False, n_iter=3)

# Also create a NaMaster field for the full-sky
field_mask_fullsky_spin0 = nmt.NmtField(mask_fullsky, None, spin=0, purify_e=False, purify_b=False, n_iter=3)
field_mask_fullsky_spin2 = nmt.NmtField(mask_fullsky, None, spin=2, purify_e=False, purify_b=False, n_iter=3)

# Create bins object using 1 ell per bin
bins = nmt.NmtBin.from_nside_linear(n_side, 1)

# Now compute the mode-coupling matrix for the mask once
print('Computing Pseudo-Cl coupling matrices')
workspace_spin0_cutsky = nmt.NmtWorkspace()
workspace_spin0_cutsky.compute_coupling_matrix(field_mask_spin0, field_mask_spin0, bins)

workspace_spin2_cutsky = nmt.NmtWorkspace()
workspace_spin2_cutsky.compute_coupling_matrix(field_mask_spin2, field_mask_spin2, bins)

# Now compute the mode-coupling matrix for the full-sky mask once
workspace_spin0_fullsky = nmt.NmtWorkspace()
workspace_spin0_fullsky.compute_coupling_matrix(field_mask_fullsky_spin0, field_mask_fullsky_spin0, bins)

workspace_spin2_fullsky = nmt.NmtWorkspace()
workspace_spin2_fullsky.compute_coupling_matrix(field_mask_fullsky_spin2, field_mask_fullsky_spin2, bins)

# Go through our ensemble of maps
for map_num in range(0, num_maps):
    if np.mod(map_num, 10) == 0:
        print(map_num, end=' ', flush=True)

    # Read in the set of maps generated by Flask
    map_kappa_nonoise, map_gamma1_nonoise, map_gamma2_nonoise = hp.read_map(
        f"{filepath}/Map_nonoise_num{map_num}-f1z1.fits", field=[0, 1, 2], dtype=np.float32)

    map_kappa_whnoise, map_gamma1_whnoise, map_gamma2_whnoise = hp.read_map(
        f"{filepath}/Map_whnoise_num{map_num}-f1z1.fits", field=[0, 1, 2], dtype=np.float32)

    # Create NaMaster field object for our maps
    field_kappa_nonoise_cutsky = nmt.NmtField(mask, [map_kappa_nonoise], purify_e=False, purify_b=False)
    field_kappa_whnoise_cutsky = nmt.NmtField(mask, [map_kappa_whnoise], purify_e=False, purify_b=False)

    field_kappa_nonoise_fullsky = nmt.NmtField(mask_fullsky, [map_kappa_nonoise], purify_e=False, purify_b=False)
    field_kappa_whnoise_fullsky = nmt.NmtField(mask_fullsky, [map_kappa_whnoise], purify_e=False, purify_b=False)

    field_gamma_nonoise_cutsky = nmt.NmtField(mask, [map_gamma1_nonoise, map_gamma2_nonoise], purify_e=False, purify_b=False)
    field_gamma_whnoise_cutsky = nmt.NmtField(mask, [map_gamma1_whnoise, map_gamma2_whnoise], purify_e=False, purify_b=False)

    field_gamma_nonoise_fullsky = nmt.NmtField(mask_fullsky, [map_gamma1_nonoise, map_gamma2_nonoise], purify_e=False, purify_b=False)
    field_gamma_whnoise_fullsky = nmt.NmtField(mask_fullsky, [map_gamma1_whnoise, map_gamma2_whnoise], purify_e=False, purify_b=False)

    # Now recover the power spectrum of these fields - cut-sky version
    cl_kappa_nonoise_coupled_cutsky = nmt.compute_coupled_cell(field_kappa_nonoise_cutsky, field_kappa_nonoise_cutsky)
    cl_kk_nonoise_cutsky = workspace_spin0_cutsky.decouple_cell(cl_kappa_nonoise_coupled_cutsky)

    cl_kappa_whnoise_coupled_cutsky = nmt.compute_coupled_cell(field_kappa_whnoise_cutsky, field_kappa_whnoise_cutsky)
    cl_kk_whnoise_cutsky = workspace_spin0_cutsky.decouple_cell(cl_kappa_whnoise_coupled_cutsky)

    cl_gamma_nonoise_coupled_cutsky = nmt.compute_coupled_cell(field_gamma_nonoise_cutsky, field_gamma_nonoise_cutsky)
    cl_gg_nonoise_cutsky = workspace_spin2_cutsky.decouple_cell(cl_gamma_nonoise_coupled_cutsky)

    cl_gamma_whnoise_coupled_cutsky = nmt.compute_coupled_cell(field_gamma_whnoise_cutsky, field_gamma_whnoise_cutsky)
    cl_gg_whnoise_cutsky = workspace_spin2_cutsky.decouple_cell(cl_gamma_whnoise_coupled_cutsky)

    # Now recover the power spectrum of these fields - full-sky version
    cl_kappa_nonoise_coupled_fullsky = nmt.compute_coupled_cell(field_kappa_nonoise_fullsky, field_kappa_nonoise_fullsky)
    cl_kk_nonoise_fullsky = workspace_spin0_fullsky.decouple_cell(cl_kappa_nonoise_coupled_fullsky)

    cl_kappa_whnoise_coupled_fullsky = nmt.compute_coupled_cell(field_kappa_whnoise_fullsky, field_kappa_whnoise_fullsky)
    cl_kk_whnoise_fullsky = workspace_spin0_fullsky.decouple_cell(cl_kappa_whnoise_coupled_fullsky)

    cl_gamma_nonoise_coupled_fullsky = nmt.compute_coupled_cell(field_gamma_nonoise_fullsky, field_gamma_nonoise_fullsky)
    cl_gg_nonoise_fullsky = workspace_spin2_fullsky.decouple_cell(cl_gamma_nonoise_coupled_fullsky)

    cl_gamma_whnoise_coupled_fullsky = nmt.compute_coupled_cell(field_gamma_whnoise_fullsky, field_gamma_whnoise_fullsky)
    cl_gg_whnoise_fullsky = workspace_spin2_fullsky.decouple_cell(cl_gamma_whnoise_coupled_fullsky)

    #* Save the power spectrum for the current realisation

    # Save the TT (kappa kappa) values
    np.savetxt(f'{filepath}/Map_nonoise_num{map_num}_Cl_PCl_kk_cutsky.dat', cl_kk_nonoise_cutsky)
    np.savetxt(f'{filepath}/Map_whnoise_num{map_num}_Cl_PCl_kk_cutsky.dat', cl_kk_whnoise_cutsky)

    np.savetxt(f'{filepath}/Map_nonoise_num{map_num}_Cl_PCl_kk_fullsky.dat', cl_kk_nonoise_fullsky)
    np.savetxt(f'{filepath}/Map_whnoise_num{map_num}_Cl_PCl_kk_fullsky.dat', cl_kk_whnoise_fullsky)

    # Save the EE values
    np.savetxt(f'{filepath}/Map_nonoise_num{map_num}_Cl_PCl_EE_cutsky.dat', cl_gg_nonoise_cutsky[0])
    np.savetxt(f'{filepath}/Map_whnoise_num{map_num}_Cl_PCl_EE_cutsky.dat', cl_gg_whnoise_cutsky[0])

    np.savetxt(f'{filepath}/Map_nonoise_num{map_num}_Cl_PCl_EE_fullsky.dat', cl_gg_nonoise_fullsky[0])
    np.savetxt(f'{filepath}/Map_whnoise_num{map_num}_Cl_PCl_EE_fullsky.dat', cl_gg_whnoise_fullsky[0])

    # Save the BB values
    np.savetxt(f'{filepath}/Map_nonoise_num{map_num}_Cl_PCl_BB_cutsky.dat', cl_gg_nonoise_cutsky[3])
    np.savetxt(f'{filepath}/Map_whnoise_num{map_num}_Cl_PCl_BB_cutsky.dat', cl_gg_whnoise_cutsky[3])

    np.savetxt(f'{filepath}/Map_nonoise_num{map_num}_Cl_PCl_BB_fullsky.dat', cl_gg_nonoise_fullsky[3])
    np.savetxt(f'{filepath}/Map_whnoise_num{map_num}_Cl_PCl_BB_fullsky.dat', cl_gg_whnoise_fullsky[3])

    # Seems like there might be a memory leak with NaMaster? Call destructor explicitly
    del field_kappa_nonoise_cutsky
    del field_kappa_whnoise_cutsky

    del field_kappa_nonoise_fullsky
    del field_kappa_whnoise_fullsky

    del field_gamma_nonoise_cutsky
    del field_gamma_whnoise_cutsky

    del field_gamma_nonoise_fullsky
    del field_gamma_whnoise_fullsky


print('...Done!')

#* Now want to compute and then save the numerical covariance matrix recovered from the above spectra

# # The number of ell modes for this n_side
# num_ell_modes = (3 * n_side - 1) - 1
#
# cl_samples_EE = np.zeros([num_maps, num_ell_modes])
# cl_samples_BB = np.zeros([num_maps, num_ell_modes])
#
# print('Reading in Cl values for covariance matrices')
# for map_num in range(num_maps):
#     cl_EE = np.loadtxt(f'{filepath}/Map{map_num}_Cl_EE_PCl.dat')
#     cl_BB = np.loadtxt(f'{filepath}/Map{map_num}_Cl_BB_PCl.dat')
#
#     cl_samples_EE[map_num] = cl_EE
#     cl_samples_BB[map_num] = cl_BB
#
# # Compute covariance matrices
# print('Computing covariance matrices')
# cl_EE_cov = np.cov(cl_samples_EE, rowvar=False)
# cl_BB_cov = np.cov(cl_samples_BB, rowvar=False)
#
# # Save covariance matrices
# print('Saving covariance matrices')
# np.savetxt(f'{filepath}/../Numerical_covariance_EE_PCl_N{n_side}.dat', cl_EE_cov)
# np.savetxt(f'{filepath}/../Numerical_covariance_BB_PCl_N{n_side}.dat', cl_BB_cov)
